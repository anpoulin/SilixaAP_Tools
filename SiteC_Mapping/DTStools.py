## \package DTStools
# \file DTStools.py
#
# \brief DTS XML file format tools
#
# \date Sep 2021
# \version 0.2
#
# Tools for importing and parsing WITSML standard XML files generated by XT
#   and Ultima DTS instruments

import numpy as np
import xml.etree.cElementTree as ElementTree


class XmlDictConfig(dict):
    '''
        Description
        -----------
        
        XmlDictConfig takes the parent element of an XML object, as parse with
        xml.etree.cElementTree, and populates all of the key/value pairs for the
        child elements in a python dictionary for easy searching.
        
        Parameters
        ----------

        dict:   python dictionary of XML object root returned by tree.getroot() method.
        
        Returns
        -------
        
        Nothing
        

        Example usage:
        
        >>> tree = ElementTree.parse('your_file.xml')
        >>> root = tree.getroot()
        >>> xmldict = XmlDictConfig(root)
        
        Or, if you want to use an XML string:
        
        >>> root = ElementTree.XML(xml_string)
        >>> xmldict = XmlDictConfig(root)
        
        And then use xmldict for what it is... a dict.
    '''
    
    def __init__(self, parent_element):
        # __init__ is the only method provided by XmlDictConfig and does
        # all of the work for this class when an XmlDictConfig object is created.
        if parent_element.items():
            self.update(dict(parent_element.items()))
        for element in parent_element:
            if element:
                # treat like dict - we assume that if the first two tags
                # in a series are different, then they are all different.
                if len(element) == 1 or element[0].tag != element[1].tag:
                    aDict = XmlDictConfig(element)
                # treat like list - we assume that if the first two tags
                # in a series are the same, then the rest are the same.
                else:
                    # here, we put the list in dictionary; the key is the
                    # tag name the list elements all share in common, and
                    # the value is the list itself
                    aDict = {element[0].tag: XmlListConfig(element)}
                # if the tag has attributes, add those to the dict
                if element.items():
                    aDict.update(dict(element.items()))
                self.update({element.tag: aDict})
            # this assumes that if you've got an attribute in a tag,
            # you won't be having any text. This may or may not be a
            # good idea -- time will tell. It works for the way we are
            # currently doing XML configuration files...
            elif element.items():
                self.update({element.tag: dict(element.items())})
            # finally, if there are no child tags and no attributes, extract
            # the text
            else:
                self.update({element.tag: element.text})


class ReadXT:
    '''
        ReadXT provides methods for reading the elements and attributes of a XT-DTS
        XML data file. This includes much of the meta-data as well as the temperature
        dataset.
    '''
    def __init__(self, file_name):
        # __init__ parses the XML file using xml.etree.cElementTree. The root and root
        # namespace attributes are also created for the ReadXY object.
        ElementTree.register_namespace('', 'http://www.witsml.org/schemas/1series')
        self.tree           = ElementTree.parse(file_name)
        self.root           = self.tree.getroot()
        self.root_namespace = self.root.tag.strip('logs')

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        pass

    def _create_dictionary(self, keys, values):
        # Create a python dictionary from key/value pairs.
        return dict(zip(keys, values))

    def _get_xml_dict(self):
        # Use the XmlDictConfig class to create a python dictionary
        # of all the elements in the ReadXT.root object.
        xml_dict = XmlDictConfig(self.root)
        return xml_dict
    
    def _get_log(self):
        # read the key/value pairs from the 'log' node and put them in
        # a python dictionary
        xml_dict    = self._get_xml_dict()
        log         = xml_dict[self.root_namespace + 'log']
        log_dict    = self._create_dictionary(log.keys(), log.values())
        return log_dict

    def get_date_time(self):
        '''
            Description
            -----------

            Get XML elements 'startDateTimeIndex' and 'endDateTimeIndex' from
            the 'log' node.
            
            Parameters
            ----------
            
            None
            
            Returns
            -------
            
            datetime_start: float value of integration start time.
            datetime_end:   float value of integration ending time.
        '''
        # Get the text of the 'startDateTimeIndex' element in the 'log' node and cast to float.
        datetime_start   = self._get_log()[self.root_namespace + 'startDateTimeIndex']
        # Get the text of the 'endDateTimeIndex' element in the 'log' node and cast to float.
        datetime_end     = self._get_log()[self.root_namespace + 'endDateTimeIndex']
        return datetime_start, datetime_end
    
    def get_start_index(self):
        '''
            Description
            -----------

            Get XML element 'startIndex' from the 'log' node.
            
            Parameters
            ----------
            
            None
            
            Returns
            -------
            
            start_index:    float value of the starting fiber index.
        '''
        # Node iterator for finding 'startIndex' element.
        start_index_generator   = self.root.iter(self.root_namespace + 'startIndex')
        # Get the text of the first element served by the generator and cast to float.
        start_index             = float( next(start_index_generator).text )
        return start_index
    
    def get_step_increment(self):
        '''
            Description
            -----------

            Get XML element 'stepIncrement' from the 'log' node.
            
            Parameters
            ----------
            
            None
            
            Returns
            -------
            
            step_increment: float value of the fiber step increment.
        '''
        # Node iterator for finding 'stepIncrement' element.
        step_increment_generator    = self.root.iter(self.root_namespace + 'stepIncrement')
        # Get the text of the first element served by the generator and cast to float.
        step_increment              = float( next(step_increment_generator).text )
        return step_increment

    def _get_log_data(self):
        '''
            Description
            -----------
            
            Get the 'logData' node from the XML file from the 'log' node.
            
            Parameters
            ----------
            
            None
            
            Returns
            -------
            
            log_data: float value of the fiber step increment.
        '''
        # Get the 'logData' node from the XML file.
        log_data        = self._get_log()[self.root_namespace + 'logData']
        return log_data
    
    def _get_mnemonic_list(self):
        '''
            Description
            -----------
            
            Get the 'mnemonicList' node from the XML file from the 'logData' node.
            
            Parameters
            ----------
            
            None
            
            Returns
            -------
            
            mnemonic_list: list object containing the strings from the 'mnemonicList' element.
        '''
        # Get the 'mnemonicList' element from the XML file.
        mnemonic_list = self._get_log_data()[self.root_namespace + 'mnemonicList']
        return mnemonic_list.split(',')

    def get_unit_list(self):
        '''
            Description
            -----------

            Get the 'unitList' element from the XML node 'logData'. This lists
            the units for the data columns.

            Parameters
            ----------
            
            None
            
            Returns
            -------
            
            unit_list: list object containing the list of physical units for DTS data columns.
        '''
        # Get the 'unitList' element from the XML file.
        unit_list = self._get_log_data()[self.root_namespace + 'unitList']
        return unit_list.split(',')

    def _get_custom_data(self):
        '''
            Description
            -----------
            
            Get the 'customData' element from the XML node 'log'.
            
            Parameters
            ----------
            
            None
            
            Returns
            -------
            
            custom_data:    dictionary containing the key/value pairs corresponding to elements in the 'customData' node.
        '''
        # Get the 'customData' node from the XML file.
        custom_data         = self._get_log()[self.root_namespace + 'customData']
        # Put the elements from the 'customData' node into a dictionary object.
        custom_data_dict    = self._create_dictionary(custom_data.keys(), custom_data.values())
        return custom_data

    def get_probe_temps(self):
        '''
            Description
            -----------

            Get the 'referenceTemperature', 'probe1Temperature' and 'probe2Temperature' elements from the 'customData' node.
            
            Parameters
            ----------
            
            None
            
            Returns
            -------
            
            ref_temp, probe_temp1, probe_temp2:   float values for the internal (ref_temp) and external (probe_temp1, probe_temp2) probe temperatures recorded during the Stokes/anti-Stokes integration.
        '''
        # Node iterator for finding 'referenceTemperature' element.
        ref_temp_generator      = self.root.iter(self.root_namespace + 'referenceTemperature')
        # Node iterator for finding 'probe1Temperature' element.
        probe_temp1_generator   = self.root.iter(self.root_namespace + 'probe1Temperature')
        # Node iterator for finding 'probe2Temperature' element.
        probe_temp2_generator   = self.root.iter(self.root_namespace + 'probe2Temperature')
        # Get the text of the first elements served by the generators and cast to floats.
        ref_temp                = float( next(ref_temp_generator).text )
        probe_temp1             = float( next(probe_temp1_generator).text )
        probe_temp2             = float( next(probe_temp2_generator).text )
        # Return prober temperatures in a dictionary so that one or multiple return values can be called for.
        return {'ref_temp': ref_temp, 'probe_temp1': probe_temp1, 'probe_temp2': probe_temp2}
    
    def _get_system_settings(self):
        '''
            Description
            -----------
            
            Get the 'systemSettings' node from the 'customData' node.
            
            Parameters
            ----------
            
            None
            
            Returns
            -------
            
            system_settings:    XML object containing the 'SystemSettings' node.
        '''
        system_settings  = self._get_custom_data()[self.root_namespace + 'SystemSettings']
        return system_settings
    
    def get_software_version(self):
        '''
            Description
            -----------

            Get the softwareVersion attribute from the 'SystemSettings' node.
            
            Parameters
            ----------
            
            None
            
            Returns
            -------
            
            software_version: string object containing the DTS system software version.
        '''
        software_version = self._get_system_settings()['softwareVersion']
        return software_version

    def get_measure_length(self, channel=1):
        '''
            Description
            -----------

            Get the value contained in the 'MeasurementLength' element.

            Parameters
            ----------

            None

            Returns
            -------

            measure_length:  Channel measurement length.

        '''
        lengthArray = []
        # Node iterator for finding 'MeasurementLength' element.
        measure_length_generator  = self.root.iter(self.root_namespace + 'MeasurementLength')
        numberChannels = len( list(measure_length_generator) )
        # Run iterator again to reset it back to the first return.
        measure_length_generator  = self.root.iter(self.root_namespace + 'MeasurementLength')
        # Get the text of the first element served by the generator and cast to float.
        if channel > numberChannels:
            measure_length = np.nan
        elif channel < 1:
            measure_length = np.nan
        else:
            for channels in range(0, channel):
                measure_length = float( next(measure_length_generator).text )
        return measure_length

    def get_reference_fiber(self):
        '''
            Description
            -----------

            Get the text contained in the 'InternalReferenceStart' and 'InternalReferenceStop' elements.

            Parameters
            ----------

            None

            Returns
            -------

            ref_start:  reference fiber start distance.
            ref_stop:   reference fiber stop distance.
        '''
        # Node iterator for finding 'InternalReferenceStart' element.
        ref_start_generator = self.root.iter(self.root_namespace + 'InternalReferenceStart')
        # Node iterator for finding 'InternalReferenceStop' element.
        ref_stop_generator  = self.root.iter(self.root_namespace + 'InternalReferenceStop')
        # Get the text of the first elements served by the generators and cast to floats.
        ref_start   = float( next(ref_start_generator).text )
        ref_stop    = float( next(ref_stop_generator).text )
        return ref_start, ref_stop

    def get_delta_alpha(self):
        '''
            Description
            -----------

            Get the value contained in the InternalDifferentialLoss element.

            Parameters
            ----------

            None

            Returns
            -------

            delta_alpha:    differential attenuation factor.
        '''
        # Node iterator for finding 'InternalDifferentialLoss' element.
        delta_alpha_generator = self.root.iter(self.root_namespace + 'InternalDifferentialLoss')
        # Get the text of the first element served by the generator and cast to float.
        delta_alpha = float( next(delta_alpha_generator).text )
        return delta_alpha

    def get_scaling_factor(self):
        '''
            Description
            -----------

            Get the value contained in the TemperatureScalingFactor element.

            Parameters
            ----------

            None

            Returns
            -------

            scale_factor:   temperature scaling factor (gamma).
        '''
        # Node iterator for finding 'TemperatureScalingFactor' element.
        scale_factor_generator = self.root.iter(self.root_namespace + 'TemperatureScalingFactor')
        # Get the text of the first element served by the generator and cast to float.
        scale_factor = float( next(scale_factor_generator).text )
        return scale_factor

    def get_acquisition_time(self):
        '''
            Description
            -----------

            Get the 'acquisitionTime' element from the 'customData' node.
            
            Parameters
            ----------
            
            None
            
            Returns
            -------
            
            acquistion_time:    float value for the Stokes/anit-Stokes integration time.
        '''
        acquisition_time = float( self._get_custom_data()[self.root_namespace + 'acquisitionTime'] )
        return acquisition_time
    
    def get_curve_calibration(self):
        '''
            Description
            -----------
            
            Get the 'StartTemperature', 'm' and 'c' elements from the 'CurveCalibrationSettings' node under the 'SystemSettings' node.
            
            Parameters
            ----------
            
            None
            
            Returns
            -------
            
            start_temperature:  float object containing the value of the startTemperature for fiber temperature curve correction.
            
            m:                  float object containing the value of the proportional correction.
            
            c:                  float object containing the value of the additive correction.
        '''
        start_temperature   = float( self._get_system_settings()[self.root_namespace + 'CurveCalibrationSettings'][self.root_namespace + 'StartTemperature'] )
        m                   = float( self._get_system_settings()[self.root_namespace + 'CurveCalibrationSettings'][self.root_namespace + 'm'] )
        c                   = float( self._get_system_settings()[self.root_namespace + 'CurveCalibrationSettings'][self.root_namespace + 'c'] )
        return start_temperature, m, c

    def get_serial_number(self):
        '''
            Description
            -----------

            Get the 'UltimatSerialNumber' element from the 'HardwareSettings' node under the
            'SystemSettings' node.
            
            Parameters
            ----------
            
            None
            
            Returns
            -------
            
            serial_number:  string object containing the DTS unit serial number.
        '''
        serial_number = self._get_custom_data()[self.root_namespace + 'SystemSettings'][self.root_namespace + 'HardwareSettings'][self.root_namespace + 'UltimaSerialNumber']
        return serial_number
    
    def get_element(self, element_name, **kwargs):
        '''
            Description
            -----------

            Get the text of a known element with name element_name.

            Parameters
            ----------

            element_name:   string object for the element to look for.

            parent:         XML object containing the element's parent.

            Returns
            -------

            element_text:   sting object containing the element text.
        '''
        # Optional keyword argument for passing a 'parent' node attribute.
        parent = kwargs.get('parent', None)
        # Initialize element_text with an empty string.
        element_text = None
        # If 'parent' keyword argument is passed only return text from element with 'parent' attributes matching the parent variable.
        if parent:
            element = parent.find( self.root_namespace + element_name )
            element_text = element.text
        # If no 'parent' keyword argument is passed just return the element text.
        else:
            for element in self.root.iter( self.root_namespace + element_name ):
                element_text = element.text
        return element_text

    def get_data(self):
        '''
            Description
            -----------

            Get the 'data' elements from the 'logData' node, iterating to place them
            in a numpy array.
            
            Parameters
            ----------
            
            None
            
            Returns
            -------
            
            data_out:   numpy array containing the DTS raw data columns.
        '''
        # Node iterator for finding all 'data' elements.
        data_generator = self.root.iter(self.root_namespace + 'data')
        # Initialize array for data.
        data_out = np.array([])
        # Iterate through the 'data' elements with the generator and append new lines to the data_out array.
        for data in data_generator:
            try:
                new_data = np.asarray( data.text.strip('\n').split(','), None ).astype(np.float)
                data_out = np.vstack( (data_out, new_data) ) if data_out.size else new_data
            except AttributeError:
                pass
        return data_out


class OverwriteXT:
    '''
        OverwriteXT provides methods for replacing elements in an XML object, as
        created using ReadXT, and writes the modified XML object out to a new file.
    '''
    def __init__(self, file_name_in, file_name_out):
        # __init__ parses the XML file using xml.etree.cElementTree. The root and root
        # namespace attributes are also created for the ReadXY object.
        ElementTree.register_namespace('', 'http://www.witsml.org/schemas/1series')
        self.tree           = ElementTree.parse(file_name_in)
        self.root           = self.tree.getroot()
        self.root_namespace = self.root.tag.strip('logs')
        self.file_name_out  = file_name_out
    
    def __enter__(self):
        return self
    
    def __exit__(self, exc_type, exc_value, traceback):
        self.tree.write( self.file_name_out )
    
    def remove_element(self, element_name, parent_name, **kwargs):
        '''
            Description
            -----------
            
            Remove the element with name element_name and parent parent_name.
            
            Parameters
            ----------
            
            element_name:   string object for the element name to remove.
            
            parent_name:    string object for the name of the element's parent.
            
            uid:            optional string object for the uid tag of the element to be removed.
            
            Returns
            -------
            
            Nothing
        '''
        # Optional keyword argument for passing a 'uid' node attribute.
        uid = kwargs.get('uid', None)
        # Need to manually set the parent of element_name tags to a variable so we can remove elements later (just keep the first hit, not the whole list).
        parent = self.root.findall( ".//" + self.root_namespace + parent_name )[0]
        # Iterate through all of the elements with the element_name tag and remove lines.
        for element in self.root.findall( ".//" + self.root_namespace + element_name ):
            # If 'uid' keyword argument is passed only remove elements with 'uid' attributes matching the uid variable.
            if uid:
                if element.get('uid') == uid:
                    parent.remove(element)
            # If no 'uid' keyword argument is passed just remove the element.
            else:
                parent.remove(element)

    def replace_element(self, element_name, element_text, **kwargs):
        '''
            Description
            -----------

            Replace the text of an element with name element_name.

            Parameters
            ----------

            element_name:   string object for the element name to modify.

            element_text:   string object containing the new text for the element.
            
            parent:         XML object containing the element's parent.

            Returns
            -------

            Nothing
        '''
        # Optional keyword argument for passing a 'parent' node attribute.
        parent = kwargs.get('parent', None)
        # If 'parent' keyword argument is passed only replace elements with 'parent' attributes matching the parent variable.
        if parent:
            element = parent.find( self.root_namespace + element_name )
            element.text = element_text
        # If no 'parent' keyword argument is passed just replace the element.
        else:
            for element in self.root.iter( self.root_namespace + element_name ):
                element.text = element_text

    def replace_attribute(self, element_name, attribute_name, attribute_text, new_attrib_text, **kwargs):
        '''
            Description
            -----------

            Replace the text of an element attribute with name attribute_name.
            Replace attribute text matching attribute_text with the new text,
            new_attribute_text.

            Parameters
            ----------

            element_name:   string object for the element name to modify.

            attribute_name: string object containing the attribute to modify.
            
            attribute_text: string object containing attribute text to be replaced.
            
            new_attrib_text:string object containing new attribute text.

            parent:         XML object containing the element's parent.

            Returns
            -------

            Nothing
        '''
        # Optional keyword argument for passing a 'uid' node attribute.
        parent = kwargs.get('parent', None)
        # If 'parent' keyword argument is passed only replace elements with 'parent' attributes matching the parent variable.
        if parent:
            element = parent.find( self.root_namespace + element_name )
            element.attrib[attribute_name] = element.get(attribute_name).replace(attribute_text, new_attrib_text)
        # If no 'parent' keyword argument is passed just replace the element.
        else:
            for element in self.root.iter( self.root_namespace + element_name ):
                element.attrib[attribute_name] = element.get(attribute_name).replace(attribute_text, new_attrib_text)

    def get_parent(self, parent_name, child_name, child_text):
        '''
            Description
            -----------

            Replace the text of a child element whose parent is parent_name with name element_name.

            Parameters
            ----------

            parent_name:    string object for the parent(s) to look for.

            child_name:     string object containing the name of the child to look for.

            child_text:     string object containing the child text to match.

            Returns
            -------

            parent:         list of XML object defining the parent with the matching child text.
        '''
        parent = []
        for single_parent in self.root.findall( ".//" + self.root_namespace + parent_name ):
            child = single_parent.find( self.root_namespace + child_name )
            if child.text == child_text:
                parent.append( single_parent )
        return parent
    
    def replace_measurement_length(self, channel_number, length):
        '''
            Description
            -----------
            
            Replace the text of a child element whose parent is parent_name with name element_name.
            
            Parameters
            ----------
            
            channel_number: string object for the channel number child to look for.
            
            channel_number: string object containing the channel number to look for.
            
            length:         string object containing the new length for the 'MeasurementLength' element.
            
            Returns
            -------
            
            Nothing
        '''
        parent = []
        for single_parent in self.root.findall( ".//" + self.root_namespace + 'ChannelConfiguration' ):
            child = single_parent.find( self.root_namespace + 'ChannelNumber' )
            if child.text == channel_number:
                parent.append( single_parent )
        if parent:
            element = parent[0].find( self.root_namespace + 'AcquisitionConfiguration' )[1]
            element.text = length

    def replace_data(self, data_array, **kwargs):
        '''
            Description
            -----------
            
            Replace the values all of the 'data' element children with the values in data_array.
            
            Parameters
            ----------
            
            data_array:         numpy array object containing the new data for the 'data' element children.
            
            doubleEnded:        optional boolean flag indicating if cable is single- or double-ended. True for double-ended, false for single-ended.
            
            terminationIndex:   optional integer value indicating the turnaournd position along the cable. This can be used to average forward- and reverse-Stokes/Anit-Stokes values.
            
            Returns
            -------
            
            Nothing
        '''
        doubleEnded         = kwargs.get('doubleEnded',         None)
        terminationIndex    = kwargs.get('terminationIndex',    None)
        i = 0
        # Need to manually set the parent of 'data' tags to a variable so we can remove elements later (just keep the first hit, not the whole list)
        parent = self.root.findall( ".//" + self.root_namespace + "logData" )[0]
        # Iterate through all of the elements with the 'data' tag and remove or replace lines as necessary
        for element in self.root.findall( ".//" + self.root_namespace + "data" ):
            # If the number of original 'data' elements has exceeded the size of the data_array then remove the element
            if i >= data_array.shape[0]:
                parent.remove(element)
            # Handle formatting and replacement of 'data' elements for single-ended, double-ended or unspecified configurations
            else:
                base_text   = '\n{:.3f},'.format(data_array[i, 0])
                mid_text    = ''
                end_text    = '{:.3f}\n'.format(data_array[i, -1])
                if doubleEnded is True:
                    for column in range(1, 5):
                        mid_text    = mid_text + '{:.3f},'.format(data_array[i, column])
                elif doubleEnded is False:
                    for column in range(1, 3):
                        mid_text    = mid_text + '{:.3f},'.format(data_array[i, column])
                elif doubleEnded is None:
                    for column in range(1, data_array.shape[1] - 1):
                        mid_text    = mid_text + '{:.3f},'.format(data_array[i, column])
                element.text = base_text + mid_text + end_text
            i += 1
        # Modify the 'startIndex' element to correct for changes in data_array
        self.replace_element('startIndex',    str(data_array[0, 0]))
        # Modify the 'endIndex' element to correct for changes in data_array
        self.replace_element('endIndex',      str(data_array[-1, 0]))
            

    def write_xml_file(self):
        '''
            Description
            -----------

            Write the XML element tree to a file specified by file_name_out, which
            is populated by the __init__ dunder of the OverwriteXT class.
            
            Parameters
            ----------
            
            None
            
            Returns
            -------
            
            Nothing
        '''
        self.tree.write( self.file_name_out )
